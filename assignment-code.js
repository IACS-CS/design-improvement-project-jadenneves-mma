/* This code drives the design improvement showcase and is NOT meant to be modified. */

/* Attribution: this code was generated by Claude Haiku 4.5 */

/**
 * Design Improvement Showcase - Responsive Scaling
 *
 * This script handles scaling designs to fit the viewport while maintaining
 * their specified dimensions. If a design is larger than the available space,
 * it scales down using CSS transforms.
 */

class DesignScaler {
  constructor() {
    this.designs = [];
    this.init();
  }

  init() {
    // Find all elements that need scaling
    this.designs = document.querySelectorAll(".design-viewport");

    // Initial setup and observation
    this.setupDesigns();
    this.observeChanges();

    // Handle window resize
    window.addEventListener("resize", () => this.scaleDesigns());

    // Handle orientation change
    window.addEventListener("orientationchange", () => {
      setTimeout(() => this.scaleDesigns(), 100);
    });
  }

  setupDesigns() {
    this.designs.forEach((viewport) => {
      const designElement = viewport.querySelector(".design-image, .my-design");
      if (designElement) {
        // Store original dimensions from .design-size class
        const width = parseInt(getComputedStyle(designElement).width, 10);
        const height = parseInt(getComputedStyle(designElement).height, 10);

        designElement.dataset.originalWidth = width;
        designElement.dataset.originalHeight = height;
      }
    });

    this.scaleDesigns();
  }

  scaleDesigns() {
    this.designs.forEach((viewport) => {
      const designElement = viewport.querySelector(".design-image, .my-design");
      if (!designElement) return;

      const originalWidth = parseInt(designElement.dataset.originalWidth, 10);
      const originalHeight = parseInt(designElement.dataset.originalHeight, 10);

      // Get available space
      const availableWidth = viewport.clientWidth - 32; // Account for padding
      const availableHeight = viewport.clientHeight - 32;

      // Calculate scale factor
      let scale = 1;

      if (originalWidth > availableWidth) {
        scale = Math.min(scale, availableWidth / originalWidth);
      }

      if (originalHeight > availableHeight) {
        scale = Math.min(scale, availableHeight / originalHeight);
      }

      // Apply scale transform
      if (scale < 1) {
        designElement.style.transform = `scale(${scale.toFixed(3)})`;
      } else {
        designElement.style.transform = "scale(1)";
      }
    });
  }

  observeChanges() {
    // Watch for changes in the design elements (if content is dynamically added)
    const observer = new MutationObserver(() => {
      this.scaleDesigns();
    });

    this.designs.forEach((viewport) => {
      observer.observe(viewport, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["class", "style"],
      });
    });
  }
}

/**
 * Design Modal - Full-size design viewer
 */
class DesignModal {
  constructor() {
    this.modal = document.getElementById("designModal");
    this.backdrop = this.modal.querySelector(".modal-backdrop");
    this.closeBtn = this.modal.querySelector(".modal-close-btn");
    this.viewport = this.modal.querySelector("#modalViewport");

    this.addSvgIcons();
    this.setupEventListeners();
  }

  addSvgIcons() {
    // Add expand icons to popout buttons
    document.querySelectorAll(".popout-btn").forEach((btn) => {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", "20");
      svg.setAttribute("height", "20");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("fill", "none");
      svg.setAttribute("stroke", "currentColor");
      svg.setAttribute("stroke-width", "2");

      const path = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      path.setAttribute(
        "d",
        "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
      );
      svg.appendChild(path);
      btn.appendChild(svg);
    });

    // Add close icon to modal close button
    const closeSvg = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    closeSvg.setAttribute("width", "24");
    closeSvg.setAttribute("height", "24");
    closeSvg.setAttribute("viewBox", "0 0 24 24");
    closeSvg.setAttribute("fill", "none");
    closeSvg.setAttribute("stroke", "currentColor");
    closeSvg.setAttribute("stroke-width", "2");

    const line1 = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );
    line1.setAttribute("x1", "18");
    line1.setAttribute("y1", "6");
    line1.setAttribute("x2", "6");
    line1.setAttribute("y2", "18");
    closeSvg.appendChild(line1);

    const line2 = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );
    line2.setAttribute("x1", "6");
    line2.setAttribute("y1", "6");
    line2.setAttribute("x2", "18");
    line2.setAttribute("y2", "18");
    closeSvg.appendChild(line2);

    this.closeBtn.appendChild(closeSvg);
  }

  setupEventListeners() {
    // Pop-out button listeners
    document.querySelectorAll(".popout-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const target = btn.dataset.target;
        this.openModal(target);
      });
    });

    // Close modal listeners
    this.closeBtn.addEventListener("click", () => this.closeModal());
    this.backdrop.addEventListener("click", () => this.closeModal());

    // Keyboard escape to close
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.modal.classList.contains("active")) {
        this.closeModal();
      }
    });
  }

  openModal(target) {
    // Clear previous content
    this.viewport.innerHTML = "";

    if (target === "original") {
      const originalImg = document.querySelector(".design-image");
      if (originalImg.src) {
        const imgClone = originalImg.cloneNode(true);
        imgClone.style.transform = "scale(1)";
        imgClone.style.maxWidth = "none";
        imgClone.style.maxHeight = "none";
        imgClone.style.width = "auto";
        imgClone.style.height = "auto";
        this.viewport.appendChild(imgClone);
      }
    } else if (target === "improvement") {
      const designContent = document.querySelector(".my-design");
      if (designContent) {
        const designClone = designContent.cloneNode(true);
        designClone.style.transform = "scale(1)";
        designClone.style.maxWidth = "none";
        designClone.style.maxHeight = "none";
        designClone.classList.remove("design-size");

        // Get original dimensions
        const originalWidth = designClone.dataset.originalWidth;
        const originalHeight = designClone.dataset.originalHeight;
        if (originalWidth) designClone.style.width = originalWidth + "px";
        if (originalHeight) designClone.style.height = originalHeight + "px";

        this.viewport.appendChild(designClone);
      }
    }

    // Show modal
    this.modal.classList.add("active");
    document.body.style.overflow = "hidden";
  }

  closeModal() {
    this.modal.classList.remove("active");
    document.body.style.overflow = "";
    this.viewport.innerHTML = "";
  }
}

// Initialize when DOM is ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    new DesignScaler();
    new DesignModal();
  });
} else {
  new DesignScaler();
  new DesignModal();
}
